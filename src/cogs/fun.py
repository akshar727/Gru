import asyncio
import base64
import json
import math
import random
import re
import string
import time
import urllib.parse
import urllib.request
from io import BytesIO

import aiohttp
import nextcord as discord
import simpleeval
from easy_pil import Editor, load_image_async
from googleapiclient.discovery import build
from nextcord.ext import commands
from num2words import num2words
from simpleeval import simple_eval

from src.utils import http, config


def calculator(exp):
    o = exp.replace('x', '*')
    o = o.replace('Ã·', '/')
    try:
        result = str(simple_eval(o))
        return result
    except AttributeError:
        result = "An error occurred"
        return result


class DropdownImageSelect(discord.ui.Select):
    def __init__(self, message, images, user):
        self.message = message
        self.images = images
        self.user = user

        options = [
            discord.SelectOption(label="1"),
            discord.SelectOption(label="2"),
            discord.SelectOption(label="3"),
            discord.SelectOption(label="4"),
            discord.SelectOption(label="5"),
            discord.SelectOption(label="6"),
            discord.SelectOption(label="7"),
            discord.SelectOption(label="8"),
            discord.SelectOption(label="9"),
        ]
        super().__init__(
            placeholder="Choose the image you want to see!",
            min_values=1,
            max_values=1,
            options=options
        )

    async def callback(self, interaction: discord.Interaction):
        if not int(self.user) == int(interaction.user.id):
            return await interaction.response.send_message("You are not the owner of this select!", ephemeral=True)
        selection = int(self.values[0]) - 1
        image = BytesIO(base64.decodebytes(self.images[selection].encode("utf-8")))
        return await self.message.edit(content="Images generated by **https://craiyon.com**",
                                       file=discord.File(image, filename="generatedImage.png"),
                                       view=DropdownImageView(self.message, self.images, self.user))


class DropdownImageView(discord.ui.View):
    def __init__(self, message, images, user):
        super().__init__()
        self.message = message
        self.images = images
        self.user = user
        self.add_item(DropdownImageSelect(self.message, self.images, self.user))


def get_hacking_text(user):
    return {
        "Trying To Access Discord Files... [â–“  ]": 0.9,
        "Trying To Access Discord Files... [â–“â–“  ]": 0.9,
        "Trying To Access Discord Files... [â–“â–“â–“ ]": 0.9,
        "Trying To Access Discord Files... [â–“â–“â–“â–“ ]": 0.9,
        "Trying To Access Discord Files... [â–“â–“â–“â–“â–“]": 0.9,
        "Successfully Accessed Discord Files! [â–“â–“â–“â–“â–“]": 0.9,
        "Trying to Access Discord Files... SUCCESS": 1,
        "Trying To Access Discord/users... [â–“  ]": 1.5,
        "Trying To Access Discord/users... [â–“â–“  ]": 1.5,
        "Trying To Access Discord/users... [â–“â–“â–“ ]": 1.5,
        "Trying To Access Discord/users... [â–“â–“â–“â–“ ]": 1.5,
        "Trying To Access Discord/users... [â–“â–“â–“â–“â–“]": 1.5,
        "Successfully Got Access to Discord/users! [â–“â–“â–“â–“â–“]": 1.5,
        "Trying to Access Discord/users... SUCCESS": 1,
        f"Trying To Access Discord/users/{user.id}... [â–“  ]": 1.5,
        f"Trying To Access Discord/users/{user.id}... [â–“â–“  ]": 1.5,
        f"Trying To Access Discord/users/{user.id}... [â–“â–“â–“ ]": 1.5,
        f"Trying To Access Discord/users/{user.id}... [â–“â–“â–“â–“ ]": 1.5,
        f"Trying To Access Discord/users/{user.id}... [â–“â–“â–“â–“â–“]": 1.5,
        f"Successfully Got Access to Discord/users/{user.id}! [â–“â–“â–“â–“â–“]": 1.5,
        f"Trying to Access Discord/users/{user.id}... SUCCESS": 1,
        f"Retrieving Login and more from discord/users/{user.name}... [â–“  ]": 1.5,
        f"Retrieving Login and more from discord/users/{user.name}... [â–“â–“  ]": 1.5,
        f"Retrieving Login and more from discord/users/{user.name}... [â–“â–“â–“ ]": 1.5,
        f"Retrieving Login and more from discord/users/{user.name}... [â–“â–“â–“â–“ ]": 1.5,
        f"Retrieving Login and more from discord/users/{user.name}... [â–“â–“â–“â–“â–“]": 1.5,
        f"Successfully Got Access to discord/users/{user.name}! [â–“â–“â–“â–“â–“]": 1.5,
        f"Retrieving Login and more from discord/users/{user.name}... SUCCESS": 1.5,
        f"Opening discord/users/{user.name}... SUCCESS": 0.7,
        "Bypassing keys...": 0.9,
        "Initializing lockdown and changing password...": 4
    }


async def run_hack(message, user):
    for text, wait_time in get_hacking_text(user).items():
        await message.edit(text)
        await asyncio.sleep(wait_time)


class Fun(commands.Cog):
    def __init__(self, bot: commands.Bot):
        self.bot = bot

    @commands.Cog.listener()
    async def on_ready(self):
        print("Fun Cog has been loaded!")

    @commands.command(aliases=["heck"])
    @commands.cooldown(1, 120, commands.BucketType.user)
    async def hack(self, ctx, user: discord.Member = None):
        if user is None:
            await ctx.reply("Please enter a user to hack!(Unless you want to hack air)")
            self.hack.reset_cooldown(ctx)
            return
        if user == self.bot:
            await ctx.reply("I AM UNHACKABLE.")
            return self.hack.reset_cooldown(ctx)
        if user.bot:
            await ctx.reply("MY KIND ARE UNHACKABLE. STAY AWAY.")
            return self.hack.reset_cooldown(ctx)
        with open('assets/countries.txt', 'r', encoding="utf8") as f:
            countries = f.read()
            countries_list = list(map(str, countries.split()))
            country = random.choice(countries_list)

        hack_msg = await ctx.reply(f"Hacking! Target: {user}...")
        await asyncio.sleep(1)
        await run_hack(hack_msg, user)
        second_part = str(user.created_at.timestamp() - 129384000)
        second_part_bytes = second_part.encode("ascii")
        base64_bytes_second_part = base64.b64encode(second_part_bytes)
        final = base64_bytes_second_part.decode("ascii")
        user_data = {
            "user": {
                "username": str(user.name),
                "id": str(user.id),
                "discriminator": str(user.discriminator),
                "bot": str(user.bot),
                "tag": str(user),
                "avatar": str(user.display_avatar.key),
                "avatarURL": str(user.display_avatar.url),
                "createdAt": str(user.created_at.strftime("%A, %B %d %Y @ %H:%M:%S %p")),
                "flags": {
                    "raw": user.public_flags.value,
                    "staff": user.public_flags.staff,
                    "partner": user.public_flags.partner,
                    "hypesquadEvents": user.public_flags.hypesquad,
                    "bugHunter": user.public_flags.bug_hunter,
                    "bugHunterLevel2": user.public_flags.bug_hunter_level_2,
                    "hypesquadBravery": user.public_flags.hypesquad_bravery,
                    "hypesquadBalance": user.public_flags.hypesquad_balance,
                    "hypesquadBrilliance": user.public_flags.hypesquad_brilliance,
                    "earlySupporter": user.public_flags.early_supporter,
                    "teamUser": user.public_flags.team_user,
                    "system": user.public_flags.system,
                    "verifiedBot": user.public_flags.verified_bot,
                    "verifiedBotDeveloper": user.public_flags.verified_bot_developer,
                    "earlyVerifiedBotDeveloper": user.public_flags.early_verified_bot_developer
                }
            }
        }
        desktop_status = user.desktop_status
        mobile_status = user.mobile_status
        raw_status = user.raw_status
        status = user.status

        member_data = {
            "member": {
                "joinedAt": str(user.joined_at.strftime("%A, %B %d %Y @ %H:%M:%S %p")),
                "activity": str(user.activity),
                "guildName": ctx.guild.name,
                "nick": str(user.nick),
                "pending": str(user.pending),
                "status": str(status),
                "rawStatus": str(raw_status),
                "mobileStatus": str(mobile_status),
                "isOnMobile": str(user.is_on_mobile()),
                "desktopStatus": str(desktop_status),
                "webStatus": str(user.web_status),
                "topRoleColor": str(user.top_role.color),
                "totalRoles": len(user.roles),
                "mention": f"<@{user.id}>",
                "displayName": user.display_name,
                "topRole": str(user.top_role)
            }
        }
        coms = ["gmail.com", "outlook.com", "yahoo.com", "hotmail.com"]
        fake_token = ""
        fake_password = ""
        last = ""
        for x in range(0, 27):
            letter_or_num = random.choice(string.ascii_letters + string.digits)
            last += letter_or_num
        user_id = str(user.id)
        user_id_bytes = user_id.encode("ascii")
        base64_bytes = base64.b64encode(user_id_bytes)
        base64_string = base64_bytes.decode("ascii")
        fake_token += f"{base64_string}.{final}.{last}"

        for x in range(0, 14):
            letter = random.choice(string.ascii_letters)
            fake_password += letter

        personal_data = {
            "personal": {
                "ipAddress": f"{random.randint(0, 200)}.{random.randint(0, 200)}"
                             f".{random.randint(0, 200)}.{random.randint(0, 200)}",
                "country": country,
                "device": random.choice(["Chromebook", "Iphone", "Ipad", "Samsung", "MacOS", "Windows", "Nokia"]),
                "emailAddress": f"{user.name}@{random.choice(coms)}",
                "password": fake_password,
                "token": fake_token
            }
        }
        hack_em = discord.Embed(title=f":unlock: Successfully Hacked {user}!",
                                description=f"{user.mention}|Here's the info I got from discord's database:",
                                color=discord.Color.yellow())
        hack_em.add_field(name=":bust_in_silhouette: User Data", value=f'```json\n{json.dumps(user_data, indent=4)}```')
        hack_em.add_field(name=":boy: Member Data", value=f'```json\n{json.dumps(member_data, indent=4)}```',
                          inline=False)
        hack_em.add_field(name=":key: Personal Data", value=f'```json\n{json.dumps(personal_data, indent=4)}```',
                          inline=False)
        await hack_msg.edit(embed=hack_em)

    @commands.command()
    async def emojify(self, ctx, *, text):
        emojis = []
        for s in text.lower():
            if s.isdecimal():
                num2emo = {
                    '0': 'zero',
                    '1': 'one',
                    '2': 'two',
                    '3': 'three',
                    '4': 'four',
                    '5': 'five',
                    '6': 'six',
                    '7': 'seven',
                    '8': 'eight',
                    '9': 'nine'
                }
                emojis.append(f':{num2emo.get(s)}:')

            elif s.isalpha():
                emojis.append(f':regional_indicator_{s}:')
            elif s == '!':
                emojis.append(':grey_exclamation:')
            elif s == '?':
                emojis.append(':grey_question:')
            elif s == "#":
                emojis.append(":hash:")
            else:
                emojis.append(s)

        await ctx.reply(' '.join(emojis))

    @commands.command()
    @commands.cooldown(1, 15, commands.BucketType.user)
    async def wanted(self, ctx, user: discord.Member = None):
        if user is None:
            user = ctx.author

        background = Editor("assets/wanted.jpeg")

        profile_pic = await load_image_async(str(user.display_avatar.url))
        profile = Editor(profile_pic).resize((300, 300))
        background.paste(profile, (78, 219))

        await ctx.reply(file=discord.File(fp=background.image_bytes, filename="wanted.jpeg"))
        await asyncio.sleep(0.5)
        if user == self.bot.user:
            await ctx.reply("Oh no that's me. I gotta RUNNNNN!!!!")

    @commands.command()
    @commands.cooldown(1, 30, commands.BucketType.user)
    async def guessing(self, ctx):
        number = random.randint(0, 100)
        channel = ctx.message.channel

        def check(m):
            return m.content is not None and m.author == ctx.author and m.channel == channel

        tries = 10
        for i in range(0, 10):
            await ctx.reply(
                f'Guess a number between 0 and 100. You have {tries} tries left')
            response = await self.bot.wait_for('message', check=check)
            try:
                guess = int(response.content)
            except ValueError:
                return await ctx.reply("The game ended because you typed an invalid guess!")
            if i == 9:
                await ctx.reply(
                    f"You lost. The number was {number}. Thanks for playing!")
                break
            if guess > number:
                await ctx.reply('Your number is too big!')
                tries -= 1
            elif guess < number:
                await ctx.reply('Your number is too small!')
                tries -= 1
            else:
                await ctx.reply('Correct! You win. Thanks for playing!')
                break
        return

    @commands.command()
    async def num2text(self, ctx, num: int = None):
        if num is None:
            await ctx.reply("Please enter a number!")
            return
        if num >= 1.000000e+306:
            await ctx.reply("Too big of a number!")
            return
        if len(num2words(num).capitalize()) > 4096:
            await ctx.reply("Too big of a number!")
            return

        new = num2words(num).capitalize()
        e = discord.Embed(title=":capital_abcd: Numbers to words",
                          description=f"**Input**:{num}\n\n**Output**:{new}",
                          color=discord.Color.random())
        e.set_footer(text=ctx.author, icon_url=ctx.author.display_avatar)
        await ctx.reply(embed=e)

    @commands.command()
    async def reverse(self, ctx, *, msg=None):
        if msg is None:
            await ctx.reply("Please enter a message!")
            return
        t_rev = msg[::-1].replace("@", "@\u200B").replace("&", "&\u200B")
        await ctx.reply(f"**ðŸ” Text ==> txeT | {ctx.author}**\n```{t_rev}```")

    @commands.command()
    async def dogfact(self, ctx):
        async with aiohttp.ClientSession() as ses:
            async with ses.get('https://some-random-api.ml/facts/dog') as r:
                if r.status in range(200, 299):
                    data = await r.json()
                    fact = data['fact']
                    em = discord.Embed(title='Dog Fact',
                                       description=f'{fact}',
                                       color=discord.Color.random())
                    await ctx.reply(embed=em)
                    await ses.close()
                else:
                    await ctx.reply("Error when making request...")
                    await ses.close()

    @commands.command()
    async def jail(self, ctx, user: discord.Member = None):
        loading = await ctx.reply("<a:loading:898340114164490261>")
        if user is None:
            user = ctx.author
        async with aiohttp.ClientSession() as trigSession:
            async with trigSession.get(
                    f'https://some-random-api.ml/canvas/jail?avatar={user.display_avatar.with_size(1024)}'
            ) as trigImg:  # get users avatar as png with 1024 size
                if trigImg.status in range(200, 299):
                    imageData = BytesIO(await
                                        trigImg.read())  # read the image/bytes
                    await trigSession.close()  # closing the session and;
                    await ctx.reply(file=discord.File(imageData, 'image.png'))
                    await loading.delete()
                else:
                    await ctx.reply("Error when making request...")
                    await trigSession.close()

    @commands.command(aliases=["trigger"])
    async def triggered(self, ctx, user: discord.Member = None):
        loading = await ctx.reply("<a:loading:898340114164490261>")
        if user is None:
            user = ctx.author
        async with aiohttp.ClientSession() as trigSession:
            async with trigSession.get(
                    f'https://some-random-api.ml/canvas/triggered?avatar={user.display_avatar.with_size(1024)}'
            ) as trigImg:
                if trigImg.status in range(200, 299):
                    imageData = BytesIO(await
                                        trigImg.read())  # read the image/bytes
                    await trigSession.close()  # closing the session and;
                    await ctx.reply(file=discord.File(imageData, 'triggered.gif'))
                    await loading.delete()
                else:
                    await ctx.reply("Error when making request...")
                    await trigSession.close()

    @commands.command()
    async def joke(self, ctx):
        async with aiohttp.ClientSession as ses:
            async with ses.get('https://some-random-api.ml/joke') as r:
                if r.status in range(200, 299):
                    data = await r.json()
                    fact = data['joke']
                    em = discord.Embed(title='Joke',
                                       description=f'{fact}',
                                       color=discord.Color.random())
                    await ctx.reply(embed=em)
                    await ses.close()
                else:
                    await ctx.reply("Error when making request...")
                    await ses.close()

    @commands.command(aliases=["gender"])
    async def genderify(self, ctx, *, name=None):
        if name is None:
            await ctx.reply("Please enter a name!")
            return

        gender_api = await http.get(f"https://api.genderize.io?name={name.lower()}",
                                    res_method="json")
        if str(gender_api["gender"]) == "None":
            return await ctx.reply("I don't have a gender for that name!")

        e = discord.Embed(title="Genderify",
                          description="I will guess the gender of a name!",
                          color=discord.Color.random())
        e.add_field(name="Name",
                    value=gender_api["name"].capitalize(),
                    inline=False)
        e.add_field(name="Gender",
                    value=gender_api["gender"].capitalize(),
                    inline=False)
        e.add_field(name="Probability",
                    value=f"{gender_api['probability'] * 100}%",
                    inline=False)
        e.add_field(name="Count", value=gender_api["count"])

        await ctx.reply("I have guessed the gender!!", embed=e)

    @commands.command()
    async def spam(self, ctx):
        await ctx.reply(
            "Type as many characters you can in 30 seconds! I will tell you when to send the message for it to be "
            "counted. "
        )
        await asyncio.sleep(1)
        countdown = await ctx.reply("3")
        await asyncio.sleep(1)
        await countdown.edit("2")
        await asyncio.sleep(1)
        await countdown.edit("1")
        await asyncio.sleep(1)
        await countdown.edit("TYPE!!!!")
        new_countdown = await ctx.reply("30")
        for num in range(30, -1, -1):
            await new_countdown.edit(f"{num}")
            await asyncio.sleep(1)
        await ctx.reply("Times up!")
        await ctx.reply(
            "Please send you message within 3 seconds or your run is disqualified!"
        )
        try:
            user_msg = await self.bot.wait_for(
                'message',
                timeout=3,
                check=lambda message: message.author == ctx.author and message.
                channel == ctx.channel)
        except asyncio.TimeoutError:
            return await ctx.reply("You ran out of time to submit your message! :(")
        if len(user_msg.content) >= 1200:
            return await ctx.reply(
                "I know you didn't type all of this in a legit way...")
        await ctx.reply(
            f"Your message was **{len(user_msg.content)}** characters long!! :tada: :tada:"
        )

    @commands.command()
    async def sqrt(self, ctx, *, expression):
        try:
            return await ctx.reply(
                f"The square root \u221A of the expression/number {expression} is"
                f"\n{math.sqrt(float(calculator(expression)))}"
            )
        except simpleeval.FeatureNotAvailable:
            return await ctx.reply(f"An error occurred :(.")

    # TODO: add to help
    @commands.command(aliases=["craiyon", "gen_img"])
    async def generate(self, ctx, *, prompt: str):
        eta = int(time.time() + 60)
        msg = await ctx.reply(f"Go grab some popcorn, this may take some time... ETA: <t:{eta}:R>")
        async with aiohttp.request("POST", "https://backend.craiyon.com/generate", json={"prompt": prompt}) as resp:
            r = await resp.json()
            images = r['images']
            image = BytesIO(base64.decodebytes(images[0].encode("utf-8")))
            return await msg.edit(content="Images generated by **https://craiyon.com**",
                                  file=discord.File(image, filename="generatedImage.png"),
                                  view=DropdownImageView(msg, images, ctx.author.id))

    @commands.command(aliases=["show"])
    async def showpic(self, ctx, *, search):
        ran = random.randint(0, 9)
        resource = build("customsearch", "v1", developerKey=config.getenv("GOOGLE_API_KEY")).cse()
        result = resource.list(q=f"{search}",
                               cx="ac76df62ee40c6a13",
                               searchType="image").execute()
        url = result["items"][ran]["link"]
        embed1 = discord.Embed(title=f"Here's Your Image ({search})",
                               color=discord.Color.random())
        embed1.set_image(url=url)
        await ctx.reply(embed=embed1)

    @commands.command()
    async def youtube(self, ctx, *, search):
        query_string = urllib.parse.urlencode({'search_query': search})
        html_content = urllib.request.urlopen('https://www.youtube.com/results?' +
                                              query_string)
        search_results = re.findall(r"watch\?v=(\S{11})",
                                    html_content.read().decode())

        await ctx.reply(
            f"Here's your video from query {search}!!\n{'https://www.youtube.com/watch?v=' + search_results[0]}")


def setup(bot):
    bot.add_cog(Fun(bot))
